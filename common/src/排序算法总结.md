# 十大排序算法要点总结

## 总览对比表

| 排序算法 | 最好时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 |
|---------|-------------|-------------|----------|-------|
| 选择排序 | $O(N^2)$ | $O(N^2)$ | $O(1)$ | 不稳定 |
| 冒泡排序 | $O(N^2)$ | $O(N^2)$ | $O(1)$ | 稳定 |
| 插入排序 | $O(N)$ | $O(N^2)$ | $O(1)$ | 稳定 |
| 希尔排序 | $O(N\log N)$ | $O(N^2)$ | $O(1)$ | 不稳定 |
| 归并排序 | $O(N\log N)$ | $O(N\log N)$ | $O(N)$ | 稳定 |
| 快速排序 | $O(N\log N)$ | $O(N^2)$ | $O(\log N)$ | 不稳定 |
| 堆排序 | $O(N\log N)$ | $O(N\log N)$ | $O(1)$ | 不稳定 |
| 计数排序 | $O(N+K)$ | $O(N+K)$ | $O(K)$ | 稳定 |
| 桶排序 | $O(N+K)$ | $O(N^2)$ | $O(N+K)$ | 稳定 |
| 基数排序 | $O(N \cdot K)$ | $O(N \cdot K)$ | $O(N+K)$ | 稳定 |

> $N$ 为数组元素个数，$K$ 在计数/基数排序中为数字范围或最大位数，在桶排序中为桶的数量。

---

## 1. 选择排序（Selection Sort）

### 基本思路
每轮从**未排序子数组**中选出最小元素，将其与未排序部分的第一个元素交换，逐步扩大已排序区间。

### 复杂度与稳定性
- **时间复杂度**：最好/最坏均为 $O(N^2)$，无论数组是否有序都需要完整比较。
- **空间复杂度**：$O(1)$，原地排序。
- **稳定性**：**不稳定**。交换操作可能改变相同元素的相对位置。

### 适用场景
- 实现简单，适合**小规模数据**。
- 不适合大规模数据排序。

---

## 2. 冒泡排序（Bubble Sort）

### 基本思路
相邻元素两两比较，如果左边大于右边则交换，每一轮将当前最大的元素"冒泡"到数组末尾。

### 复杂度与稳定性
- **时间复杂度**：最好/最坏均为 $O(N^2)$。
- **空间复杂度**：$O(1)$，原地排序。
- **稳定性**：**稳定**。只在严格大于时交换，不会改变相同元素的相对位置。

### 适用场景
- 代码简单易懂，适合**小规模数据**和教学场景。
- 对已排好序的列表效率极低（存在多余重复比较）。

---

## 3. 插入排序（Insertion Sort）

### 基本思路
假设前 $i-1$ 个元素已排好序，将第 $i$ 个元素从后往前逐一比较，找到合适的位置插入。

### 优化版本——折半插入
将查找插入位置的过程从逐一比较改为**二分查找**，比较次数从 $O(N^2)$ 降至 $O(N\log N)$，但移动元素的操作仍为 $O(N^2)$，优化效果在比较开销大于移动开销时才显著。

### 复杂度与稳定性
- **时间复杂度**：最好 $O(N)$（数组已有序），最坏 $O(N^2)$。
- **空间复杂度**：$O(1)$。
- **稳定性**：**稳定**。

### 适用场景
- 数据量较小且**大部分已排好序**的场景。
- 经常用作快速排序和归并排序的**辅助算法**。

---

## 4. 希尔排序（Shell Sort）

### 基本思路
插入排序的改进版本。通过设置递减的**增量序列**（如 $n/2, n/4, \ldots, 1$），对间隔为 gap 的子序列分别进行插入排序。随着 gap 逐渐缩小至 1，数组趋于有序，最终一轮插入排序即可高效完成。

### 复杂度与稳定性
- **时间复杂度**：最好 $O(N\log N)$（增量序列选择得当），最坏 $O(N^2)$。
- **空间复杂度**：$O(1)$。
- **稳定性**：**不稳定**。不同子序列间的交换会打乱相同元素的相对位置。

### 适用场景
- 适合用作**复杂排序算法的预处理**排序。
- 充分利用插入排序在有序状态下的线性效率。

---

## 5. 归并排序（Merge Sort）

### 基本思路
典型的**分治思想**：将大数组一分为二，递归地对左右子数组排序，最后将两个有序子数组**合并**为一个有序数组。

### 复杂度与稳定性
- **时间复杂度**：$O(N\log N)$。拆分需要 $\log N$ 层，每层合并需要 $O(N)$。
- **空间复杂度**：$O(N)$，合并过程中需分配额外数组。
- **稳定性**：**稳定**。合并时相同元素按原顺序归入。

### 适用场景
- 适用于**大规模数据**与**外部排序**（磁盘文件排序）。
- 对小规模数据，递归开销可能不如插入/冒泡排序高效。

---

## 6. 快速排序（Quick Sort）

### 基本思路
选取一个**基准元素（pivot）**，通过双指针将数组划分为"小于 pivot"和"大于 pivot"两部分，递归对两部分继续排序。

### 优化策略

#### 优化1：三数取中法
从数组首、中、尾三个元素中取中位数作为 pivot，避免数组近乎有序时退化到 $O(N^2)$。

#### 优化2：三向切分（3-Way QuickSort）
将数组分为**小于、等于、大于**基准三部分，对大量重复元素的数组效率远优于普通快排。重复元素多时接近 $O(N)$。

#### 优化3：双枢轴快速排序（Dual-Pivot QuickSort）
选取两个基准 $p_1, p_2$，将数组划分为三个区间（$<p_1$、$[p_1,p_2]$、$>p_2$），递归树高度从 $\log_2 N$ 降至 $\log_3 N$。这是 Java `Arrays.sort()` 的默认排序方式。

### 复杂度与稳定性
- **时间复杂度**：最好 $O(N\log N)$，最坏 $O(N^2)$（数组已有序且未优化 pivot 选取）。
- **空间复杂度**：$O(\log N)$，递归栈开销。
- **稳定性**：**不稳定**。

### 适用场景
- 处理**大规模随机数据**的通用排序算法，平均性能优异。
- 小规模数据排序效率较低。

---

## 7. 堆排序（Heap Sort）

### 基本思路
1. 将数组构建为**大根堆**（从最后一个非叶子节点开始自底向上调整）。
2. 将堆顶（最大值）与末尾元素交换，缩小堆的范围。
3. 对新的堆顶元素重新调整为大根堆，重复直到有序。

### 复杂度与稳定性
- **时间复杂度**：$O(N\log N)$。建堆 $O(N)$，每次调整 $O(\log N)$，共 $N$ 次。
- **空间复杂度**：$O(1)$，在原数组上操作。
- **稳定性**：**不稳定**。父子节点间的大量交换会改变相同元素的相对顺序。

### 适用场景
- 适合**大规模内存排序**。
- 小规模场景下性能可能不如插入排序。

---

## 8. 计数排序（Counting Sort）

### 基本思路
**非比较型排序**。统计每个元素出现的次数，存入计数数组，然后按照计数数组顺序将元素复写回原数组。

### 复杂度与稳定性
- **时间复杂度**：$O(N+K)$，$N$ 为元素个数，$K$ 为数值范围。
- **空间复杂度**：$O(K)$，需额外的计数数组。
- **稳定性**：**稳定**。顺序遍历保证相同元素按原始相对位置落入。

### 适用场景
- 排序**范围较小的整数数组**。
- 适合外部排序（磁盘文件）。
- **仅适用于整数且有限范围内的数据**。

---

## 9. 桶排序（Bucket Sort）

### 基本思路
**分布式排序算法**。利用映射函数将元素分配到不同的桶中，对每个桶内部使用其他排序算法（如快排）排序，最后按桶的顺序依次合并。

### 复杂度与稳定性
- **时间复杂度**：$O(N + K \cdot m\log m)$，其中 $K$ 为桶数，$m$ 为桶内平均元素数。数据均匀分布时接近 $O(N)$。
- **空间复杂度**：$O(N+K)$。
- **稳定性**：**稳定**（取决于桶内排序算法的稳定性）。

### 适用场景
- 数据**分布均匀**时性能优异。
- 广泛应用于**外部排序**，如超大乱序文件的拆分-排序-合并。

---

## 10. 基数排序（Radix Sort）

### 基本思路
**非比较型排序**。从最低位到最高位，按每一位将元素分配到 0~9 号桶中，每轮按桶顺序收集回数组。经过最大位数 $K$ 轮后数组有序。对于含负数的数组，先做偏移处理（减去最小值），排序后再恢复。

### 复杂度与稳定性
- **时间复杂度**：$O(N \cdot K)$，$K$ 为最大数的位数。
- **空间复杂度**：$O(N+K)$，需要额外的桶空间。
- **稳定性**：**稳定**。相同元素按原始相对位置放入桶中。

### 适用场景
- 数字范围较小且最大位数 $K$ 不大的**整数数据排序**。
- 适合外部排序（磁盘文件）。
